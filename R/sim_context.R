#' @param nbElems_int Number of elements in the set (strictly positive integer).
#' @param quantitatives_mat Characteristics of quantitative variables
#' to generate.
#' If it's a vector, it must be of size 2. The first element indicates the mean,
#' and the second element indicates the standard deviation.
#' If `nbQuantitatives > 0`,
#' as many i.i.d. variables will be generated with the data specified
#' in the vector.
#' If it's a matrix, it should have 2 columns. The first column corresponds
#' to the means of the independent quantitative variables to be generated.
#' The second column corresponds to the standard deviation of these variables.
#' Each row corresponds to a variable.
#' All quantitative variables follow a normal distribution.
#' (vector of size 2, matrix with 2 columns, or NULL)
#' @param qualitatives_list List of vectors where each vector contains
#' the categories of the qualitative variables to generate. Each qualitative
#' variable will be generated by drawing uniformly from its categories.
#' (list of vectors or NULL)
#' @param nbQuantitatives If `quantitatives_mat` is a vector, indicates
#' the number of quantitative variables to generate with the characteristics
#' defined in `quantitatives_mat`. Ignored otherwise. (positive or zero integer)
#' @returns A dataframe with `nbElems_int` rows containing the
#' generated quantitative and qualitative variables. Qualitative variables
#' are stored as factors.
#' @name gen_context
NULL

# Randomly generates a context with an arbitrary number of quantitative and
# qualitative variables for a set of elements.
#' @importFrom stats rnorm
#' @importFrom checkmate assertCount assertNumeric assertMatrix
gen_context <- function(nbElems_int,
                        quantitatives_mat = c(0.0, 1.0),
                        qualitatives_list = NULL,
                        nbQuantitatives_int = 0L)
{

  # Checking arguments
  assertCount(nbElems_int, positive = TRUE)

  context_df <- data.frame(matrix(nrow = nbElems_int, ncol = 0L))

  # Case where quantitatives_mat is a vector (normally of two elements):
  # nbQuantitatives_int must indicate the number of i.i.d. quantitative
  # variables (with the mean and variance indicated in quantitatives_mat)
  # to be generated.
  if (is.vector(quantitatives_mat))
  {
    assertCount(nbQuantitatives_int)

    # If nbQuantitatives_int is 0 then no quantitative variables are generated.
    if (nbQuantitatives_int == 0L)
      quantitatives_mat <- NULL
    else
    {
      assertNumeric(quantitatives_mat, finite = TRUE,
                    any.missing = FALSE,
                    all.missing = FALSE,
                    len = 2L)

      quantitatives_mat <- matrix(rep(quantitatives_mat, nbQuantitatives_int),
                                  byrow = TRUE, ncol = 2L)

      nbQuantitatives_int <- nrow(quantitatives_mat)
    }
  }

  # Case where there are quantitative variables to generate
  if (!is.null(quantitatives_mat))
  {
    assertMatrix(quantitatives_mat,
                 min.rows = 1L, ncols = 2L,
                 mode = "numeric",
                 any.missing = FALSE,
                 all.missing = FALSE)

    assertNumeric(quantitatives_mat[, 2L], lower = 0.0)

    # Simulating quantitative variables with normal distribution
    quant_df <- cbind(context_df, apply(quantitatives_mat, 1L,
                                        function(var) rnorm(nbElems_int,
                                                            var[1L],
                                                            var[2L])))

    colnames(quant_df) <- paste("quant", seq_len(nrow(quantitatives_mat)),
                                sep = "_")

    context_df <- cbind(context_df, quant_df)
  }

  # Case where there are qualitative variables to generate
  if (!is.null(qualitatives_list))
  {
    if (!is.list(qualitatives_list))
    {
      stop("`qualitatives_list` must be a list (or NULL)")
    }

    if (length(qualitatives_list) == 0L)
    {
      warning("`qualitatives_list` is empty")
    }

    # For each element in the list, we get the set of possible values for the
    # associated qualitative variable
    qualitatives_list <-
      lapply(qualitatives_list,
             function(v)
             {
               if (is.null(v) || length(v) == 0L)
               {
                 stop("At least one element in `qualitatives_list` has size zero") # nolint: line_length_linter
               }
               if (is.vector(v))
                 return(unique(v))

               else if (is.factor(v))
                 return(levels(v))

               else
               {
                 stop("At least one element in `qualitatives_list` is not a vector or factor") # nolint: line_length_linter
               }

             })
    qual_df <-
      lapply(qualitatives_list,
             function(v)
             {
               res <- as.factor(sample(v, size = nbElems_int, replace = TRUE))
               levels(res) <- v
               res
             })

    qual_df <- as.data.frame(qual_df)

    colnames(qual_df) <- paste("qual", seq_along(qualitatives_list), sep = "_")
    # If the elements in the list are named, we use these names for the
    # variables in the context dataframe,
    # unless these names are already used
    if (!is.null(names(qualitatives_list)))
    {
      mask <- names(qualitatives_list) != "" &
        !(names(qualitatives_list) %in% colnames(context_df))

      colnames(qual_df)[mask] <- names(qualitatives_list)[mask]
    }

    context_df <- cbind(context_df, qual_df)
  }

  if (ncol(context_df) == 0L)
    warning("No context has been generated")

  context_df
}
