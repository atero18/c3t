% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AHR_grid.R
\name{AHR}
\alias{AHR}
\title{Agglomerative Hierarchical Regionalisation (AHR)}
\usage{
AHR(
  distances = NULL,
  contiguity = NULL,
  sizes = NULL,
  d = NULL,
  data = NULL,
  m = 0,
  M = Inf,
  standardQuant = FALSE,
  binarQual = FALSE,
  nbTries = 5L,
  propFusionsInit = 0.01,
  linkages = "saut_min",
  fusionConstraints = NA,
  fusionConstraintModes = available_fusion_modes(),
  splitConnectedComponents = FALSE,
  criteria = NULL,
  evalLinkages = linkages,
  minNbClusters = 2L,
  maxNbClusters = Inf,
  parallele = TRUE,
  nbCores = detectCores() - 1L,
  verbose = TRUE
)
}
\arguments{
\item{distances}{The distance matrix of the problem. This can be omitted
if a distance function \code{d} and data context \code{data} are provided. If only
\code{distances} is provided, all distances must be present. (distance matrix)}

\item{contiguity}{A contiguity matrix or an \code{igraph} contiguity graph. If not
provided, the problem is considered completely contiguous (all elements are
neighbors of each other). In that case solving time might be long for each
iteration.}

\item{sizes}{Represents the size of each element. By default, it is set
to \code{1} for each element (the size of a cluster becomes its cardinal).
All data must be positive or zero. (positive real numeric vector)}

\item{d}{Distance function between elements. This can be omitted if
\code{distances} is already indicated. If present, \code{data} must also be
specified. Some classical distances are available, it is recommended to use
them rather than a personal function for optimisation reasons :
\itemize{
\item "\code{euclidean}": Euclidean distance.
\item "\code{manhattan}" : Manhattan distance.
\item "\code{minkowski}" : Minkowski's distance. In that case a value for p >= 1
must be specified.
}

(function or string)}

\item{data}{A data.frame where each row represents data related to an
element. This can be omitted if \code{d} is omitted. Present variables can
be quantitative or qualitative. If qualitative variables are present,
some distances may not be used. Possibility of standardising variables and
transforming qualitative variables into binary variables (one-hot encoding)
using \code{standardQuant} and \code{binarQual}. (data.frame)}

\item{m}{Minimum size constraint. Must be positive or zero and small enough
for the problem to be feasible. Default is \code{0} (no constraint).
(positive number)}

\item{M}{Maximum size constraint. Must be positive, superior or equal to \code{m}
and large enough for the problem to be feasible. Default is \code{Inf}
(no constraint). Multiple values can be given if different values for the
maximum size constraint must be tried.
(positive real vector)}

\item{standardQuant}{\code{TRUE} if the variables in \code{data} should be
standardised (i.e., centered and scaled), \code{FALSE} (default) otherwise.
Standardisation is applied after the possible binarization of qualitative
variables (see \code{binarQual}). (flag)}

\item{binarQual}{\code{TRUE} if qualitative variables should be binarized (one-hot
encoding), for example, to make the data set compatible with common distances
or to standardize these variables. \code{FALSE} (default) otherwise. (flag)}

\item{nbTries}{The number of initialisations to test. The first one will
start from a single-element partition, and the remaining ones will
be generated randomly respecting connectivity and maximum cluster size
constraints. The number of random fusions to perform for each randomly
generated partition is determined by \code{propFusionsInit}.
(strictly positive integer)}

\item{propFusionsInit}{Proportion of fusions (relatively to the number
of elements) to be randomly performed for the initialisations. Ignored if
\code{nbTries = 1}. Default is \verb{1\%}. (value in ]0,1[)}

\item{linkages}{A vector of distance measures to be tested. Can
include both function names and actual distance functions. These measures
determine the linkage criterion for the hierarchical clustering.
If using custom  distance functions, they must take the pairwise distance
matrix as an argument and return the linkage distance. Default implemented
linkages can be seen with \code{\link[=available_linkages]{available_linkages()}}.}

\item{fusionConstraints}{Type of constraints to add on the fusions.
When a new fusion must be done the algorithm will choose the best fusion
in term of the linkage distance respecting the constraint. If no fusion check
the constraint a partial relaxation is realized. This kind of constraint can
be useful when the problem have a minimum size constraint. Multiple values
can be given.
The implemented constraints are the following:
\itemize{
\item \code{FALSE} (or \code{NA}): no constraint added
\item "\code{singletonMin}": fusion between a cluster of one element and a cluster
which doesn't verify the minimum size constraint.
\item "\code{singletonAny}" : fusion between a cluster of one element and any other
cluster
\item "\code{minMin}" : fusion between clusters which do not verify the minimum
size constraint
\item "\code{minAny}" : fusion between a cluster which do not verify the minimum
size constraint and any other one.
(vector)
}}

\item{fusionConstraintModes}{The way the fusion constraint, if any has been
supplied in \code{fusionConstraints} parameters (ignored otherwise)
should be applied. Actually two modes are available:
\itemize{
\item "\code{deterministic}": the fusion constraint is applied constantly until it is
unfeasible.
\item "\code{random}": the fusion constraint is applied randomly with a probability
increasing with the number of iterations.
}

Default to "deterministic". (character vector)}

\item{splitConnectedComponents}{A flag indicating if AHR should be done
independently on connected components. This can consequently improve
calculation time if the problem is not connected and will not impact the
results of the AHR. If \code{TRUE} the grid will be realized on the different
connected components and the return will be a list with one element
per component. Ignored if the problem is connected.
Default to \code{FALSE}. (flag)}

\item{criteria}{A vector of criteria for cluster evaluation to be
calculated at the end of the hierarchical clustering. Optional.
Use \code{\link[=available_criteria]{available_criteria()}} to see what criteria are
available. (character vector, possibly \code{NULL})}

\item{evalLinkages}{a vector of linkages that will be used by each criterion
in \code{criteria} needing this parameter. By default it is equal to \code{linkages}.}

\item{minNbClusters}{Minimum number of clusters allowed. Default is \code{2}.
Setting a higher value for \code{minNbClusters} can reduce computation time.
(strictly positive integer)}

\item{maxNbClusters}{Maximum number of clusters allowed. At the end of
each iteration if solutions with a number of cluster inferior to this value
exist, those with a superior number of clusters will be removed. Must be
superior or equal to \code{minNbClusters}. Can reduce computation time.
Default to \code{Inf}. (strictly positive integer)}

\item{parallele}{Logical indicating whether to use parallel processing.
Default is TRUE.}

\item{nbCores}{Number of CPU cores to use for parallel processing
(sockets method). Default is one less than the detected number of cores.}

\item{verbose}{Logical indicating whether to display progress messages.
Default is TRUE.}
}
\value{
Depending on \code{splitConnectedComponents} and if the problem is
connected or not.
If \code{splitConnectedComponents = FALSE} or the problem is connected, a list
with 3 elements:
\itemize{
\item \code{results}: A \link[tibble:tibble-package]{tibble} containing partitions given
by AHR with some information like  what constraint are respected.
If at least one feasible solution have been found only those will be return,
with calculated criteria if any given in \code{criteria}. If at least one
criterion is given results will be order by quality regarding the
first criterion.
Otherwise every solution will be returned, ordered by their size constraint
score.
\item \code{grid}: the different parameters used for each AHR in a
\link[tibble:tibble-package]{tibble}.
\item \code{initialPartitions}: the different partitions that have been used for
the first iteration of the AHRs. Stored in a
\link[tibble:tibble-package]{tibble}.
}

Otherwise a list with one element per connected component. Each of the
elements are a list corresponding to the return of this function for
the connected component.
}
\description{
This function performs Agglomerative Hierarchical Clustering
(AHC)  on a given problem of regionalisation
(contiguity/connectivity constraint) with
optional size constraints on the clusters. Multiple iterations of AHR can be
made if multiple values are given for some
parameters.
}
\details{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
}
\examples{
set.seed(123L)
grid  <- simple_grid(4L, 5L)
data <- grid$context
sizes <- grid$repartition$nbIndividuals
contiguity <- grid$contiguity

m <- 200.0
M <- 800.0

d <- "euclidean"

criterion <- 'CHI'

AHR(contiguity = contiguity,
    d = d, data = data,
    sizes = sizes,
    m = m, M = M,
    criteria = criterion,
    nbTries = 1L,
    fusionConstraints = available_fusion_constraints(),
    fusionConstraintModes = available_fusion_modes(),
    parallele = FALSE)
}
\seealso{
\code{\link[=merge_cc_partitions]{merge_cc_partitions()}}

\code{\link[stats:hclust]{stats::hclust()}} if you don't have any constraint.
}
