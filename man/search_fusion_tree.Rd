% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fusionTree.R
\name{search_fusion_tree}
\alias{search_fusion_tree}
\alias{AHR_fusion_tree}
\title{Search of a fusion tree under connectivity and/or size constraints.}
\usage{
search_fusion_tree(
  distances = NULL,
  contiguity = NULL,
  sizes = NULL,
  d = NULL,
  data = NULL,
  m = 0L,
  M = Inf,
  standardQuant = FALSE,
  binarQual = FALSE,
  search = "DFS",
  stopCriterion = "first_valid_branch",
  childChoice = "distance",
  regionalisation = NULL,
  linkage = "complete"
)

AHR_fusion_tree(
  distances = NULL,
  contiguity = NULL,
  sizes = NULL,
  d = NULL,
  data = NULL,
  m = 0L,
  M = Inf,
  standardQuant = FALSE,
  binarQual = FALSE,
  regionalisation = NULL,
  linkage = "complete"
)
}
\arguments{
\item{distances}{The distance matrix of the problem. This can be omitted
if a distance function \code{d} and data context \code{data} are provided. If only
\code{distances} is provided, all distances must be present. (distance matrix)}

\item{contiguity}{A contiguity matrix or an \code{igraph} contiguity graph. If not
provided, the problem is considered completely contiguous (all elements are
neighbors of each other).}

\item{sizes}{Represents the size of each element. By default, it is set
to \code{1} for each element (the size of a cluster becomes its cardinal).
All data must be positive or zero. (positive real numeric vector)}

\item{d}{Distance function between elements. This can be omitted if
\code{distances} is already indicated. If present, \code{data} must also be
specified. Some classical distances are available, it is recommended to use
them rather than a personal function for optimisation reasons :
\itemize{
\item "\code{euclidean}": Euclidean distance.
\item "\code{manhattan}" : Manhattan distance.
\item "\code{minkowski}" : Minkowski's distance. In that case a value for p >= 1
must be specified.
}

(function or string)}

\item{data}{A data.frame where each row represents data related to an
element. This can be omitted if \code{d} is omitted. Present variables can
be quantitative or qualitative. If qualitative variables are present,
some distances may not be used. Possibility of standardising variables and
transforming qualitative variables into binary variables (one-hot encoding)
using \code{standardQuant} and \code{binarQual}. (data.frame)}

\item{m}{Minimum size constraint. Must be positive or zero and small enough
for the problem to be feasible. Default is \code{0} (no constraint).
(positive number)}

\item{M}{Maximum size constraint. Must be positive, superior or equal to \code{m}
and large enough for the problem to be feasible.
Default is \code{Inf} (no constraint). (positive number)}

\item{standardQuant}{\code{TRUE} if the variables in \code{data} should be
standardised (i.e., centered and scaled), \code{FALSE} (default) otherwise.
Standardisation is applied after the possible binarization of qualitative
variables (see \code{binarQual}). (flag)}

\item{binarQual}{\code{TRUE} if qualitative variables should be binarized (one-hot
encoding), for example, to make the data set compatible with common distances
or to standardize these variables. \code{FALSE} (default) otherwise. (flag)}

\item{search}{Type of traversal to apply on the fusion tree.
Three possibilities:
\itemize{
\item "\code{BFS}" (Depth First Search)
\item "\code{DFS}" (Breadth First Search)
\item "\code{random}" (random)
}}

\item{stopCriterion}{Indicates when the traversal should stop.
The possibilities are as follows:
\itemize{
\item "\code{full}": The algorithm stops when all possible fusions from the initial
partition have been evaluated.
\item "\code{first_valid_node}": Stop when a first feasible solution is found.
Useful when a minimum size constraint is present.
\item "\code{first_valid_branch}": Stop as soon as a node without fusion has been
selected and a feasible solution has been found.
}}

\item{childChoice}{In the case of breadth-first or depth-first search,
the way in which child nodes are ordered (and accessed). Multiple choices:
\itemize{
\item "\code{random}": Children are ordered randomly.
\item "\code{first_valid_node}": Initial order is preserved.
\item "\code{distance}": Nodes are ordered by increasing inter-cluster distance.
}}

\item{regionalisation}{regionalisation to start the tree traversal.}

\item{linkage}{used when \verb{chilChoice = } \code{"distance"}. Can
be a function or a string. This determines the linkage criterion and
so the selection of the children nodes.
If using custom  distance function, it must take the pairwise distance
matrix as an argument and return the linkage distance. Default implemented
linkages can be seen with \code{\link[=available_linkages]{available_linkages()}}.}
}
\description{
Search of a fusion tree under connectivity and/or size constraints.
}
\details{
The triplet
(\code{search} = "\code{DFS}", \code{childChoice} = "\code{distance}",
\code{stopCriterion} = "\code{first_valid_branch}")
corresponds to an Agglomerative Hierarchical Clustering (AHC) with
contiguity and size constraints, not necessarily stopping at the fusion of
two clusters but when a feasible partition is found.
The two methods are equivalent when there is no minimum size constraint.
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}
}
\section{Functions}{
\itemize{
\item \code{AHR_fusion_tree()}: Shortcut for \code{search_fusion_tree}
in the case of an AHC / AHR search.

}}
\seealso{
\code{\link[=AHR]{AHR()}}
}
